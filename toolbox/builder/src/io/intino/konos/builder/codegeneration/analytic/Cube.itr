def type(cube & src)
	package $package.analytic.cubes;

    import io.intino.alexandria.Timetag;
    import io.intino.alexandria.led.buffers.store.ByteStore;

    import $package.analytic.Axis;
    import $package.analytic.axes.*;

    import java.io.File;
    import java.util.*;
    import java.util.function.Predicate;
    import java.util.stream.Collectors;

	public class $name+FirstUpperCase extends Abstract$name+FirstUpperCase {

		public $name+FirstUpperCase(List<Loader> loaders) {
			super(loaders);
		}

		[$customDimension+staticMethod...[$NL$NL]]

		[$customFilter+staticMethod...[$NL$NL]]

		@Override
		public $name+FirstUpperCase execute() {
		    super.execute();
		    return this;
		}

		public static List<Axis> dimensions() {
            return List.of([$dimension+getInstance...[, ]]);
        }

		public static class Loader extends Abstract$name+FirstUpperCase.Loader {

		    [$splitted+create]

			public Loader(Datasource datasource[, $split+parameter]) {
				super(datasource[, $split+name]);
			}

			// TODO write here a cache if necessary
		}

		public static class Fact extends Abstract$name+FirstUpperCase.AbstractFact {

		    public Fact(ByteStore store) {
		        super(store);
		    }

		    [$virtualColumn+implementation...[$NL$NL]]
		}

		public static class Aggregation extends Abstract$name+FirstUpperCase.AbstractAggregation {

		    public Aggregation(Timetag timetag, List<Axis.Component> components, Map<Axis, Predicate<Fact>> filters) {
		        super(timetag, components, filters);
		    }

		    [$customIndicator+implementation...[$NL$NL]]
		}
	}
end

def type(cube)
	package $package.analytic.cubes;

    import io.intino.alexandria.Timetag;
    import io.intino.alexandria.led.LedReader;
    import io.intino.alexandria.led.LedStream;
    import io.intino.alexandria.led.Schema;
    import io.intino.alexandria.led.allocators.SchemaFactory;
    import io.intino.alexandria.led.buffers.store.ByteStore;
    import io.intino.alexandria.led.util.iterators.MergedIterator;
    import io.intino.alexandria.led.util.collections.SparseLongList;

	import $package.analytic.axes.*;
    import $package.analytic.Axis;

	import java.io.File;
    import java.util.*;
    import java.util.stream.Collectors;
    import java.util.function.Function;
    import java.util.function.Predicate;
    import java.util.stream.Stream;
    import java.util.stream.StreamSupport;

    import static java.util.Comparator.comparingLong;
    import static java.util.Spliterators.spliteratorUnknownSize;

    import $package.analytic.cubes.$name+FirstUpperCase.Fact;
    import $package.analytic.cubes.$name+FirstUpperCase.Aggregation;

    @SuppressWarnings("unused")
    public abstract class Abstract$name+FirstUpperCase implements Iterable<Aggregation> {

		public static final Fact NULL_FACT = new NullFact();

		private final List<? extends Loader> loaders;
		private Predicate<Fact> filter = fact -> true;
		private final List<Axis> axes = new ArrayList<>();
		private final Map<Axis, Set<Axis.Component>> components = new HashMap<>();
		private final List<Function<Fact, ? extends Axis.Component>> groupByList = new ArrayList<>();
		private final Map<Axis, Predicate<Fact>> filters = new LinkedHashMap<>();
		private Aggregation$[] result;

    	public Abstract$name+FirstUpperCase(List<? extends Loader> loaders) {
    		this.loaders = java.util.Objects.requireNonNull(loaders);
    	}

    	[$dimension+method...[$NL$NL]]

    	[$customFilter+method...[$NL$NL]]

    	public Abstract$name+FirstUpperCase groupBy(Axis axis) {
    	    if(axis == null) throw new NullPointerException("Axis cannot be null");
    	    switch(axis.getLabel()) {
    	        [$dimension+switchCaseGroupBy...[$NL]]
    	    }
            return this;
    	}

        @SuppressWarnings("unchecked")
    	public Abstract$name+FirstUpperCase filter(Axis axis, Set<? extends Axis.Component> components) {
    	    if(axis == null) throw new NullPointerException("Axis cannot be null");
    	    switch(axis.getLabel()) {
    	        [$dimension+switchCaseFilter...[$NL]]
    	    }
            return this;
        }

        public static Function<Fact, Axis.Component> dimension(Axis axis) {
            if(axis == null) throw new NullPointerException("Axis cannot be null");
            switch(axis.getLabel()) {
                [$dimension+switchCaseFunction...[$NL]]
            }
            return fact -> null;
        }

		public Abstract$name+firstUpperCase execute() {
			result = new Aggregation$[resultsSize()];
			results().forEach(this::append);
			fillCategories();
			return this;
		}

		public Aggregation$[] result() {
            if(result == null) return new Aggregation$[0];
            return Arrays.stream(result).filter(java.util.Objects::nonNull).toArray(Aggregation$[]::new);
        }

		@Override
		public Iterator<Aggregation> iterator() {
		    return result == null
                ? Stream.<Aggregation>empty().iterator()
                : Arrays.stream(result).filter(java.util.Objects::nonNull).iterator();
		}

		public static List<Axis> dimensions() {
		    return List.of([$dimension+getInstance...[, ]]);
		}

		public boolean contains(Axis axis, Axis.Component component) {
		    if(!components.containsKey(axis)) return false;
		    return components.get(axis).contains(component);
		}

    	public Iterator<Fact> detail() {
			MergedIterator<Fact> iterator = new MergedIterator<>(loaders.stream().map(Iterable::iterator), comparingLong(Fact::id));
			return StreamSupport.stream(spliteratorUnknownSize(iterator, Spliterator.SORTED), false).filter(this::check).iterator();
		}

		public Aggregation aggregation(List<Axis.Component> components) {
		    final int index = indexOf(components);
			return result$[index];
		}

	    public Aggregation aggregation(Axis.Component... components) {
            final int index = indexOf(components);
        	return result$[index];
        }

		private void fillCategories() {
			for (Aggregation aggregation : result) {
				if (aggregation == null) continue;
				for (int i = 0; i < aggregation.components.size(); i++)
					components.get(axes.get(i)).add(aggregation.components.get(i));
			}
		}

		private int resultsSize() {
			int accumulator = 1;
			for (Axis axis : axes) accumulator *= axis.getSize() + 1;
			return accumulator;
		}

		private Stream<Aggregation$[]> results() {
			return loaders.parallelStream().map(this::results);
		}

		private Aggregation$[] results(Iterable<Fact> facts) {
			Aggregation$[] result = new Aggregation$[resultsSize()];
			for (Fact fact : facts) {
			    fact.setCube(this);
				if (!check(fact)) continue;
				Axis.Component$[] components = componentsOf(fact);
				int index = indexOf(components);
				if (result$[index] == null) result$[index] = new Aggregation(fact.timetag(), Arrays.asList(components), filters);
				result$[index].append(fact);
			}
			return result;
		}

		private synchronized void append(Aggregation$[] results) {
			for (int i = 0; i < results.length; i++) {
			    final Aggregation aggregation = results$[i];
				if (aggregation == null) continue;
				if (result$[i] == null)
                    result$[i] = aggregation;
                else
                    result$[i].append(aggregation);
			}
		}

		private int indexOf(Axis.Component$[] components) {
			int index = 0;
			for (int i = 0; i < components.length; i++) {
				index *= axes.get(i).getSize();
				index += components$[i].index();
			}
			return index;
		}

		private int indexOf(Collection<Axis.Component> components) {
        	int index = 0;
        	int i = 0;
        	for (Axis.Component component : components) {
        		index *= axes.get(i++).getSize();
        		index += component.index();
        	}
        	return index;
        }

		private boolean check(Fact item) {
		    return filter.test(item);
		}

		private Axis.Component$[] componentsOf(Fact item) {
			Axis.Component$[] components = new Axis.Component$[groupByList.size()];
			for (int i = 0; i < components.length; i++) components$[i] = groupByList.get(i).apply(item);
			return components;
		}

		public static abstract class AbstractFact extends Schema {

            public static final int SIZE = $size; // Bytes
            public static final UUID SERIAL_UUID = UUID.fromString("$serialUUID");
            public static final SchemaFactory<Fact> FACTORY = new SchemaFactory<>(Fact.class) {
                @Override
                public Fact newInstance(ByteStore store) {
                    return new Fact(store);
                }
            };

            private Timetag timetag;
            private Abstract$name+FirstUpperCase cube;

            public AbstractFact(ByteStore store) {
            	super(store);
            }

            [$virtualColumn+abstract...[$NL$NL]]

            [$column+getter...[$NL$NL]]

            @Override
            public long id() {
            	return $id();
            }

            public final Abstract$name+FirstUpperCase cube() {
                return cube;
            }

            void setCube(Abstract$name+FirstUpperCase cube) {
                this.cube = cube;
            }

            public final Timetag timetag() {
                return timetag;
            }

            void setTimetag(Timetag timetag) {
                this.timetag = timetag;
            }

            @Override
            public int size() {
            	return SIZE;
            }

            @Override
            public UUID serialUUID() {
                return SERIAL_UUID;
            }

             @Override
             public String toString() {
                 return "$name+FirstUpperCase~.Fact{"
                         + "id=" + id()
                         + ", timetag=" + timetag()
                         [$column+toString...[$NL]]
                         + '}';
             }
        }

		public static class NullFact extends Fact {

			public static final int SIZE = Fact.SIZE; // Bytes
			public static final UUID SERIAL_UUID = Fact.SERIAL_UUID;
            public static final SchemaFactory<NullFact> FACTORY = new SchemaFactory<>(NullFact.class) {
                @Override
            	public NullFact newInstance(ByteStore store) {
            	    return new NullFact();
            	}
            };

			private NullFact() {
				super(ByteStore.empty());
			}

			@Override
			public long id() {
				return $id();
			}

			@Override
			public int size() {
				return SIZE;
			}

			@Override
			public UUID serialUUID() {
			    return SERIAL_UUID;
			}
		}

		public enum Indicator {

		    Total("Total", "", Mode.Sum, false),
		    Distincts("Distincts", "", Mode.Sum, false),
		    [$indicator+enum...[,$NL]]
		    [,$customIndicator+enum...[,$NL]];


		    public static Indicator byName(String name) {
		        return Arrays.stream(values()).filter(i -> i.name().equalsIgnoreCase(name)).findFirst().orElse(null);
		    }

		    public final String title;
		    public final String unit;
		    public final Mode mode;
		    public final boolean virtual;

		    Indicator(String title, String unit, Mode mode, boolean virtual) {
		        this.title = title;
		        this.unit = unit;
		        this.mode = mode;
		        this.virtual = virtual;
		    }

		    public enum Mode {
		        Sum, Average
		    }
		}

		public static abstract class AbstractAggregation {

		    protected static final long Long_NaN = Long.MIN_VALUE;

            protected final Timetag timetag;
			protected final List<Axis.Component> components;
			protected final Map<Axis, Predicate<Fact>> filters;
			protected long aggregationTotal = 0L;
			protected long aggregationDistincts = 0L;
			protected long lastID = Long.MIN_VALUE;
			[$index+field]
			$indicator+field...[$NL]
			$customIndicator+field...[$NL]

			public AbstractAggregation(Timetag timetag, List<Axis.Component> components, Map<Axis, Predicate<Fact>> filters) {
				this.timetag = timetag;
				this.components = components;
				this.filters = filters;
			}

			public void append(Fact fact) {
				[$indicator+sum...[$NL]]
				if (lastID != fact.id()) {
				    [$index+append]
                    ++aggregationDistincts;
                    lastID = fact.id();
                }
                ++aggregationTotal;
			}

			public void append(AbstractAggregation aggregation) {
				[$indicator+sumAggregation...[$NL]]
				[$index+append2]
				aggregationDistincts = Math.max(aggregationDistincts(), aggregation.aggregationDistincts());
				aggregationTotal += aggregation.aggregationTotal();
			}

			public long aggregationTotal() {
				return aggregationTotal;
			}

			public long aggregationDistincts() {
			    return aggregationDistincts;
			}

			[$index+getter]

			public Timetag timetag() {
                return timetag;
            }

			public List<Axis.Component> components() {
				return components;
			}

			[$indicator+getter...[$NL$NL]]

			[$customIndicator+getter...[$NL$NL]]

			public Number indicator(Indicator indicator) {
                switch(indicator) {
                    [$indicator+switchCase...[$NL]]
                    [$customIndicator+switchCase...[$NL]]
                    case Total: return aggregationTotal;
                    case Distincts: return aggregationDistincts;
                }
                return 0L;
            }

			@Override
			public String toString() {
			    return "$name+FirstUpperCase.Aggregation{"
			        + "total=" + aggregationTotal
			        + ", distincts=" + aggregationDistincts
			        [$index+toString...[$NL]]
			        [$indicator+toString...[$NL]]
			        [$customIndicator+toString...[$NL]]
			        + "}";
			}
		}

    	public static class Loader implements Iterable<Fact> {

			protected final Datasource datasource;
			[$split+field]

			public Loader(Datasource datasource[, $split+parameter]) {
				this.datasource = datasource;
				[$split+assign]
			}

			@Override
			public Iterator<Fact> iterator() {
			    return datasource.leds($split+name).asJavaStream().iterator();
			}

			[$split+method]

			public static class Datasource {

				private final File root;
				private final Timetag from;
				private final Timetag to;

				public Datasource(File root, Timetag from, Timetag to) {
					this.root = root;
					this.from = from;
					this.to = to;
				}

				public Timetag from() {
					return from;
				}

				public Timetag to() {
					return to;
				}

				private LedStream<Fact> leds($split+parameter) {
					return LedStream.merged(StreamSupport.stream(from.iterateTo(to).spliterator(), false).map(t -> on(t[, $split+name])));
				}

				private LedStream<Fact> on(Timetag timetag[, $split+parameter]) {
					File file = new File(root + "/$name+FirstUpperCase" [+ "." + $split+name], timetag.value() + ".led");
					LedStream<Fact> facts = file.exists() ? new LedReader(file).read(Fact.class) : LedStream.empty(Fact.class);
					return facts.peek(fact -> fact.setTimetag(timetag));
				}
			}
		}
    }
end

def type(indicator) trigger(enum)
    $fieldName+CamelCase+FirstUpperCase~("$label", "$unit", Mode.$mode, false)
end

def type(customIndicator) trigger(enum)
    $fieldName+CamelCase+FirstUpperCase~("$label", "$unit", Mode.$mode, true)
end

def type(indicator) trigger(switchCase)
    case $fieldName+CamelCase+FirstUpperCase: return $name+snakeCaseToCamelCase+FirstLowerCase;
end

def type(customIndicator) trigger(switchCase)
    case $fieldName+CamelCase+FirstUpperCase: return $name+snakeCaseToCamelCase+FirstLowerCase;
end

def type(index) trigger(field)
	private final SparseLongList ids = new SparseLongList();
end

def type(index) trigger(append)
	ids.add(fact.id());
end

def type(index) trigger(append2)
	ids.addAll(aggregation.ids);
end

def type(index) trigger(getter)
	public List<Long> ids() {
		return ids.asList();
	}
end

def trigger(nbits)
	NBits
end

def type(customFilter) trigger(method)
	public Abstract$cube+firstUpperCase filter$name+snakeCaseToCamelCase+firstUpperCase() {
	    filter = filter.and($cube+FirstUpperCase::$name+snakeCaseToCamelCase+firstLowerCase~Filter);
		return this;
	}
end

def type(customFilter) trigger(staticMethod)
	public static boolean $name+snakeCaseToCamelCase+firstLowerCase~Filter(Fact fact) {
		// TODO: write here your code
		return true;
	}
end

def type(customDimension) trigger(staticMethod)
	public static $name+snakeCaseToCamelCase+firstLowerCase[$isDistribution~Range] $name+snakeCaseToCamelCase+firstLowerCase~Function() {
	    // TODO: write here your code
		return v -> null;
	}
end

def type(dimension & categorical) trigger(switchCaseGroupBy)
    case $axis+snakeCaseToCamelCase+firstUpperCase.AXIS_LABEL: return groupBy$name+snakeCaseToCamelCase+firstUpperCase();
end

def type(dimension & categorical) trigger(switchCaseFunction)
    case $axis+snakeCaseToCamelCase+firstUpperCase.AXIS_LABEL: return $cube+FirstUpperCase::$name+snakeCaseToCamelCase+firstLowerCase~Function;
end

def type(dimension & categorical) trigger(switchCaseFilter)
    case $axis+snakeCaseToCamelCase+firstUpperCase.AXIS_LABEL: return filter$name+snakeCaseToCamelCase+firstUpperCase((Set<$axis+snakeCaseToCamelCase+firstUpperCase.Component>) components);
end

def type(dimension) trigger(getInstance)
    $axis+snakeCaseToCamelCase+firstUpperCase.get()
end

def type(dimension & categorical) trigger(method)
	public Abstract$cube+firstUpperCase filter$name+snakeCaseToCamelCase+firstUpperCase(Set<$axis+snakeCaseToCamelCase+firstUpperCase.Component> $axis+snakeCaseToCamelCase+firstLowerCase) {
		if(filters.containsKey($axis+snakeCaseToCamelCase+firstUpperCase.get())) return this;
		Predicate<Fact> f = v -> $name+snakeCaseToCamelCase+firstLowerCase~Filter(v, $axis+snakeCaseToCamelCase+firstLowerCase);
		filters.put($axis+snakeCaseToCamelCase+firstUpperCase.get(), f);
		filter = filter.and(f);
		return this;
	}

	public Abstract$cube+FirstUpperCase groupBy$name+snakeCaseToCamelCase+firstUpperCase() {
		axes.add($axis+snakeCaseToCamelCase+firstUpperCase.get());
		components.put($axis+snakeCaseToCamelCase+firstUpperCase.get(), new HashSet<>());
		groupByList.add(Abstract$cube+FirstUpperCase::$name+snakeCaseToCamelCase+firstLowerCase~Function);
		return this;
	}

	public static boolean $name+snakeCaseToCamelCase+firstLowerCase~Filter(Fact fact, Set<$axis+snakeCaseToCamelCase+firstUpperCase.Component> $axis+snakeCaseToCamelCase+firstLowerCase) {
		return $axis+snakeCaseToCamelCase+firstLowerCase.contains($name+snakeCaseToCamelCase+firstLowerCase~Function(fact));
	}

	public static $axis+snakeCaseToCamelCase+firstUpperCase.Component $name+snakeCaseToCamelCase+firstLowerCase~Function(Fact fact) {
		return fact.$source+snakeCaseToCamelCase+firstLowerCase()[.$child+snakeCaseToCamelCase+firstLowerCase()];
	}
end

def type(dimension & continuous) trigger(method)
	public Abstract$cube+firstUpperCase filter$name+snakeCaseToCamelCase+firstUpperCase(Set<$axis+snakeCaseToCamelCase+firstUpperCase.Range> $axis+snakeCaseToCamelCase+firstLowerCase) {
		if(filters.containsKey($axis+snakeCaseToCamelCase+firstUpperCase.get())) return this;
        Predicate<Fact> f = v -> $name+snakeCaseToCamelCase+firstLowerCase~Filter(v, $axis+snakeCaseToCamelCase+firstLowerCase);
        filters.put($axis+snakeCaseToCamelCase+firstUpperCase.get(), f);
        filter = filter.and(f);
        return this;
	}

	public Abstract$cube+snakeCaseToCamelCase+FirstUpperCase groupBy$name+snakeCaseToCamelCase+firstUpperCase() {
		axes.add($axis+snakeCaseToCamelCase+firstUpperCase.get());
		components.put($axis+snakeCaseToCamelCase+firstUpperCase.get(), new HashSet<>());
		groupByList.add(Abstract$cube+FirstUpperCase::$name+snakeCaseToCamelCase+firstLowerCase~Function);
		return this;
	}

	public static boolean $name+snakeCaseToCamelCase+firstLowerCase~Filter(Fact fact, Set<$axis+snakeCaseToCamelCase+firstUpperCase.Range> $axis+snakeCaseToCamelCase+firstLowerCase) {
		return $axis+snakeCaseToCamelCase+firstLowerCase.contains($name+snakeCaseToCamelCase+firstLowerCase~Function(fact));
	}

	public static $axis+snakeCaseToCamelCase+firstUpperCase.Range $name+snakeCaseToCamelCase+firstLowerCase~Function(Fact fact) {
		return $axis+snakeCaseToCamelCase+firstUpperCase.rangeOf(fact.$source+snakeCaseToCamelCase+firstLowerCase());
	}
end


def type(customDimension & continuous) trigger(method)
	public Abstract$cube+snakeCaseToCamelCase+firstUpperCase filter$name+firstUpperCase(Set<$axis+snakeCaseToCamelCase.Range> ranges) {//TODO
		filter = filter.and(v -> $name+firstLowerCase~Filter(v, ranges));
		return this;
	}

	public Abstract$cube+snakeCaseToCamelCase+firstUpperCase groupBy$name+firstUpperCase() {
		axes.add($axis+snakeCaseToCamelCase.get);
		components.put($axis+snakeCaseToCamelCase.get, new HashSet<>());
		groupByList.add(Abstract$cube+firstUpperCase::$name+snakeCaseToCamelCase+firstLowerCase~Function);
		return this;
	}

	public static boolean $name+snakeCaseToCamelCase+firstLowerCase~Filter(Fact fact, Set<$axis+snakeCaseToCamelCase.Range> rangos) {
		return rangos.contains($cube+firstUpperCase.$name+snakeCaseToCamelCase+firstLowerCase~Function(fact));
	}
end

def type(indicator) trigger(toString)
	 + ", $name+firstLowerCase=" + $name+firstLowerCase~()
end

def type(customIndicator) trigger(toString)
	 + ", $name+firstLowerCase=" + $name+firstLowerCase~()
end

def type(indicator) trigger(sum)
	$name+firstLowerCase += fact.$source+firstLowerCase();
end

def type(indicator) trigger(sumAggregation)
	$name+firstLowerCase += aggregation.$name+firstLowerCase;
end

def type(indicator & average) trigger(field)
	private double $name+firstLowerCase;
end

def type(customIndicator & average) trigger(field)
	private double $name+firstLowerCase = Double.NaN;
end

def type(indicator & sum) trigger(field)
	private long $name+firstLowerCase;
end

def type(customIndicator & sum) trigger(field)
	private long $name+firstLowerCase = Long_NaN;
end

def type(indicator & average) trigger(getter)
	public double $name+firstLowerCase() {
		return $name+firstLowerCase / (double) aggregationDistincts;
	}
end

def type(customIndicator & average) trigger(getter)
	public final double $name+firstLowerCase() {
		if(Double.isNaN($name+firstLowerCase))
		    $name+firstLowerCase = calculate$name+firstUpperCase();
		return $name+firstLowerCase;
	}

	protected abstract double calculate$name+firstUpperCase();
end

def type(indicator & sum) trigger(getter)
	public long $name+firstLowerCase() {
		return $name+firstLowerCase;
	}
end

def type(customIndicator & sum) trigger(getter)
	public final long $name+firstLowerCase() {
		if($name+firstLowerCase == Long_NaN)
		    $name+firstLowerCase = calculate$name+firstUpperCase();
		return $name+firstLowerCase;
	}

	protected abstract long calculate$name+firstUpperCase();
end

def type(index) trigger(index)
	ids.size()
end

def type(indicator & average) trigger(staticMethod)
	public static double $name(Fact fact) {
		return 0.0;
	}
end

def type(indicator & sum) trigger(staticMethod)
	public static long $name(Fact fact) {
		return 0;
	}
end

def type(customIndicator & sum) trigger(implementation)
	@Override
	protected long calculate$name+firstUpperCase() {
	    // TODO: calculate and return $name+firstLowerCase
		return 0;
	}
end

def type(customIndicator & average) trigger(implementation)
	@Override
	protected double calculate$name+firstUpperCase() {
	    // TODO: calculate and return $name+firstLowerCase
		return 0.0;
	}
end

def type(split) trigger(parameter)
	String $name+firstLowerCase
end

def type(split) trigger(setParameter)
	Set<String> $name+firstLowerCase
end

def type(split) trigger(assign)
	this.$name+firstLowerCase = $name+firstLowerCase;
end

def type(split) trigger(name)
	$name+firstLowerCase
end

def type(split) trigger(nameUpper)
	$name+firstUpperCase
end

def type(split) trigger(field)
	protected final String $name+firstLowerCase;
end

def type(split) trigger(method)
	private static Set<String> all$name+FirstUpperCase() {
		return java.util.Set.of($value+quoted...[, ]);
	}
end

def type(dimension) trigger(ifGroupBy)
    if(axis.equals($axis+snakeCaseToCamelCase+firstUpperCase.get())) return groupBy$name+snakeCaseToCamelCase+firstUpperCase();
end

def type(dimension) trigger(ifFilterBy)
    if(axis.equals($axis+snakeCaseToCamelCase+firstUpperCase.get())) return filter$name+snakeCaseToCamelCase+firstUpperCase();
end

def trigger(dimension)
	public static Predicate<$cube+FirstUpperCase.Fact> $axis+snakeCaseToCamelCase+firstLowerCase(Set<$axis+snakeCaseToCamelCase+firstUpperCase.Component> $axis+snakeCaseToCamelCase+firstLowerCase~List) {
		return r -> $axis+snakeCaseToCamelCase+firstLowerCase~List.contains(r.$axis+snakeCaseToCamelCase+firstLowerCase());
	}

	public static Function<$cube+FirstUpperCase.Fact, String> $axis+snakeCaseToCamelCase+firstLowerCase() {
		return r -> r.$axis+snakeCaseToCamelCase+firstLowerCase().id();
	}
end

def type(column) trigger(toString)
    + ", $name=" + $name()
end

def type(splitted) attribute(splitted:true) trigger(create)
    public static List<Loader> create(File root, Timetag from, Timetag to, Collection<String> split) {
        return split.stream().map(s -> new Loader(new Loader.Datasource(root, from, to), s)).collect(Collectors.toList());
    }
end

def type(splitted) attribute(splitted:false) trigger(create)
    public static List<Loader> create(File root, Timetag from, Timetag to) {
        return List.of(new Loader(new Loader.Datasource(root, from, to)));
    }
end


