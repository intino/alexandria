def type(service)
	package $package+ValidPackage;

	import $package+validPackage.$box+snakecaseToCamelCase+firstUpperCase~Box;
	import io.intino.alexandria.http.AlexandriaSpark;
	import io.intino.alexandria.logger.Logger;
	import io.intino.alexandria.scheduler.AlexandriaScheduler;
	import org.apache.commons.io.FileUtils;
	$schemaImport
	import org.quartz.*;

	import java.io.File;
	import java.io.IOException;
	import java.nio.file.Files;
	import java.time.Instant;
	import java.time.temporal.ChronoUnit;
	import java.util.*;
	import java.util.function.Predicate;
	import java.util.stream.Collectors;

	import static io.intino.alexandria.Json.fromString;
	import static org.quartz.CronScheduleBuilder.cronSchedule;
	import static org.quartz.JobBuilder.newJob;
	import static org.quartz.TriggerBuilder.newTrigger;

	@SuppressWarnings("unchecked")
	public class FuturesService {
		public static final String BasePath = "$basePath/";
		private static final Map<String, File> sources = new HashMap<>();
		private static final Map<String, Instant> timeouts = new HashMap<>();
		private final TrooperBox box;
		private final File root;

		public FuturesService(TrooperBox box) {
			this.box = box;
			this.root = box.archetype().futures().root();
		}

		$future+getter...[$NL$NL]

		$future+execute...[$NL$NL]

		public AlexandriaSpark<?> setup(AlexandriaSpark<?> server, AlexandriaScheduler scheduler) {
			loadFutures();
			startTimers(scheduler);
			startService(server);
			return server;
		}

		public Create create() {
			return new Create();
		}

		private void startTimers(AlexandriaScheduler scheduler) {
			try {
				JobDetail job = newJob(FuturesServiceTrigger.class).withIdentity("FuturesServiceTrigger").build();
				job.getJobDataMap().put("box", box);
				scheduler.scheduleJob(job, Set.of(newTrigger().withIdentity("FutureServiceTrigger").withSchedule(cronSchedule("* * * 1/1 * ? *")).build()), true);
			} catch (SchedulerException e) {
				Logger.error(e);
			}
		}

		private void startService(AlexandriaSpark<?> server) {
			$future+route...[$NL]
		}

		$future+register...[$NL]

		private void loadFutures() {
			$future+load...[$NL]
		}

		$future+private...[$NL]

		private static String read(File file) {
			try {
				return Files.readString(file.toPath());
			} catch (IOException e) {
				Logger.error(e);
				return "";
			}
		}

		public class Create {
			$future+createMethod...[$NL$NL]

			$future+createClass...[$NL$NL]
		}

		public static class Option {
			String id = UUID.randomUUID().toString();
		}

		private static class FuturesServiceTrigger implements Job {

			public void execute(JobExecutionContext context) throws JobExecutionException {
				TrooperBox box = (TrooperBox) context.getMergedJobDataMap().get("box");
				final Instant instant = Instant.now().truncatedTo(ChronoUnit.SECONDS);
				timeouts.forEach((k, v) -> {
					if (v.equals(instant)) {
						$future+timeout...[$NL]
					}
				});
			}
		}
	}
end

def trigger(register)
	private void register$name+firstUpperCase($name+firstUpperCase~Schema schema) {
		register(schema, $name+firstLowerCase~File($parameter+schemaParameter...[, ]));
	}

	private static void register($name+firstUpperCase~Schema schema, File file) {
		$option+putOption...[$NL]
		timeouts.put("$name+firstUpperCase#" + schema.timeout().id, schema.timeout().timeout);
	}
end

def trigger(load)
	$name+firstLowerCase~Files().forEach(file -> register(fromString(read(file), $name+firstUpperCase~Schema.class), file));
end

def trigger(route)
	server.route(BasePath + Abstract$name+firstUpperCase.URI.Path + ":id").post(manager -> execute$name+firstUpperCase(manager.fromPath("id")));
end

def trigger(ifOption)
	if ("$name".equals(option)) schema.$name();
end

def trigger(putOption)
	sources.put(schema.$name().id, file);
end

def trigger(private)
	private Collection<File> $name+firstLowerCase~Files() {
		return FileUtils.listFiles(new File(root, "$name+camelCaseToSnakeCase/"), new String$[]{"json"}, true);
	}

	private File $name+firstLowerCase~File($parameter+signature...[, ]) {
		return new File(root, "$name+camelCaseToSnakeCase/" + $parameter+name...[ + "." + ] + ".json");
	}

	private $name+firstUpperCase $name+firstLowerCase(File file) {
		final $name+firstUpperCase future = new $name+firstUpperCase(box);
		future.schema = fromString(read(file), $name+firstUpperCase~Schema.class);
		return future;
	}

end
def trigger(execute)
	public void execute$name+firstUpperCase(String id) {
		final File file = sources.get(id);
		if (file == null) return;
		final $name+firstUpperCase schema = $name+firstLowerCase(file);
		final String option = schema.uri().option(id);
		if (option == null) return;
		$option+ifOption...[$NL else ]
		schema.uri().ids().forEach(sources::remove);
		file.delete();
	}
end

def trigger(getter)
	public List<$name+firstUpperCase> all$name+firstUpperCase($parameter+predicateSignature...[, ]) {
		return $name+firstLowerCase~Files().stream()
				.filter(f -> $parameter+test...[&&]))
				.map(this::$name+firstLowerCase).collect(Collectors.toList());
	}

	public $name+firstUpperCase $name+firstLowerCase~($parameter+signature...[, ]) {
		return $name+firstLowerCase($name+firstLowerCase~File($parameter+name...[, ]));
	}
end

def trigger(createMethod)
	public $name+firstUpperCase $name+firstLowerCase($parameter+signature...[, ]) {
		return new $name+firstUpperCase($parameter+name...[, ]);
	}
end

def trigger(timeout)
	if (k.startsWith("$name+FirstUpperCase#")) box.futuresService().execute$name+FirstUpperCase(k.split("#")$[1]);
end

def trigger(predicateSignature)
	Predicate<$type> $name
end

def trigger(signature)
	$type $name
end

def trigger(name)
	$name
end

def trigger(test)
	$name.test(f.getName().split("\\.")$[$index])
end

def trigger(schemaParameter)
	schema.$name
end

def trigger(fluid)
	.$name+firstLowerCase($name+firstLowerCase)
end

def trigger(optionCreate)
	public $future+firstUpperCase($parameter+signature...[, ]) {
		schema.reject(new $future+firstUpperCase~Schema.Reject($parameter+name...[, ]));
		return this;
	}
end

def trigger(createClass)
	public class $name+firstUpperCase {
		private final $name+firstUpperCase~Schema schema;

		public $name+firstUpperCase($parameter+signature...[, ]) {
			schema = new $name+firstUpperCase~Schema()$parameter+fluid...[.];
		}

		$option+optionCreate...[$NL]

		public $name+firstUpperCase timeout(Instant timeout) {
			schema.timeout(new $name+firstUpperCase~Schema.Timeout(timeout.truncatedTo(ChronoUnit.SECONDS)));
			return this;
		}

		public void save() {
			register$name+firstUpperCase~(schema);
		}
	}
end

def type(schemaImport)
	import $package.schemas.*;
end